{
  "version": 3,
  "sources": ["../../node_modules/floyd-warshall/src/index.js", "../../index.js", "../../graphInterfaces.js"],
  "sourcesContent": ["'use strict'\n\n/** Calculator for finding widest and/or shortest paths in a graph using the Floyed-Warshall algorithm. */\nclass FloydWarshall {\n\n  /**\n   * Create a Floyd-Warshall calculator for a specific adjacency matrix.\n   * @param {number[][]} adjacencyMatrix - A square matrix representing a graph with weighted edges.\n   */\n  constructor (adjacencyMatrix) {\n    this.adjacencyMatrix = adjacencyMatrix\n  }\n\n  /**\n   * Calculates the widest distance from one node to the other.\n   * @return {number[][]} - Matrix with distances from a node to the other\n   */\n  get widestPaths () {\n    let distMatrix = this._initializeDistanceMatrix(0)\n    for (let k = 0; k < this.order; ++k) {\n      for (let i = 0; i < this.order; ++i) {\n        if (i === k) { continue }\n        for (let j = 0; j < this.order; ++j) {\n          if (j === i || j === k) { continue }\n          const direct = distMatrix[i][j]\n          const detour = Math.min(distMatrix[i][k], distMatrix[k][j])\n          if (detour > direct) {\n            distMatrix[i][j] = detour\n          }\n        }\n      }\n    }\n    return distMatrix\n  }\n\n  /**\n   * Calculates the shortest paths of the weighted graph.\n   * (The output will not be accurate if the graph has a negative cycle.)\n   * @return {number[][]} - Matrix with distances from a node to the other\n   */\n  get shortestPaths () {\n    let distMatrix = this._initializeDistanceMatrix(Infinity)\n\n    for (let k = 0; k < this.order; ++k) {\n      for (let i = 0; i < this.order; ++i) {\n        for (let j = 0; j < this.order; ++j) {\n          let dist = distMatrix[i][k] + distMatrix[k][j]\n          if (distMatrix[i][j] > dist) {\n            distMatrix[i][j] = dist\n          }\n        }\n      }\n    }\n\n    for (let i = 0; i < this.order; ++i) {\n      for (let j = 0; j < this.order; ++j) {\n        if (distMatrix[i][j] === Infinity) {\n          distMatrix[i][j] = -1\n        }\n      }\n    }\n\n    return distMatrix\n  }\n\n  /**\n   * Get the order of the adjacency matrix (and of the output distance matrices.)\n   * @return {integer} The order of the adjacency matrix.\n   */\n  get order () {\n    return this.adjacencyMatrix.length\n  }\n\n  /**\n   * @private\n   */\n  _initializeDistanceMatrix (blankFiller) {\n    let distMatrix = []\n    for (let i = 0; i < this.order; ++i) {\n      distMatrix[i] = []\n      for (let j = 0; j < this.order; ++j) {\n        if (i === j) {\n          distMatrix[i][j] = 0\n        } else {\n          let val = this.adjacencyMatrix[i][j]\n          if (val) {\n            distMatrix[i][j] = val\n          } else {\n            distMatrix[i][j] = blankFiller\n          }\n        }\n      }\n    }\n    return distMatrix\n  }\n\n}\n\nmodule.exports = FloydWarshall\n", "import FloydWarshall from \"floyd-warshall\";\nimport graphInterfaceDefault from \"./graphInterfaces\";\n\nfunction buildUnweightedAdjacencyMatrix(\n  nodes = [],\n  edges = [],\n  graphInterface = {}\n) {\n  graphInterface = { ...graphInterfaceDefault, ...graphInterface };\n  const { getNodeId, getSource, getTarget } = graphInterface;\n  var adj = [];\n  for (var i = 0; i < nodes.length; i++) {\n    adj[i] = new Array(nodes.length);\n  }\n\n  edges.forEach((edge) => {\n    adj[\n      nodes.indexOf(nodes.find((node) => getNodeId(node) == getSource(edge)))\n    ][\n      nodes.indexOf(nodes.find((node) => getNodeId(node) == getTarget(edge)))\n    ] = 1;\n  });\n  return adj;\n}\n\nconst iterateUndirected = (adjacencyMatrix, iterFn) => {\n  // only iterate over the upper triangular part of the adjacency matrix\n  for (let i = 0; i < adjacencyMatrix.length; i++) {\n    const row = adjacencyMatrix[i];\n    for (let j = i; j < row.length; j++) {\n      const entryValue = row[j];\n      iterFn(i, j, entryValue);\n    }\n  }\n};\n\nconst iterateDirected = (adjacencyMatrix, iterFn) => {\n  // use the whole adjacency matrix to build edges\n  adjacencyMatrix.forEach((row, i) => {\n    row.forEach((entryValue, j) => {\n      iterFn(i, j, entryValue);\n    });\n  });\n};\n\nconst defaultOptions = {\n  directed: true,\n  graphInterface: {},\n};\n\nexport function graphHops(\n  nodes,\n  edges,\n  opts = defaultOptions\n) {\n  let { directed, graphInterface, makeHop } = opts;\n  // fallback to defaults\n  graphInterface = {...graphInterfaceDefault, ...graphInterface, ...opts};\n  // if a `makeHop` function is specified in the options use that one\n\n  makeHop = makeHop || graphInterface.makeHop;\n  // make the graph's adjacency matrix and find all shortest paths\n  const adjacencyMatrix = buildUnweightedAdjacencyMatrix(\n    nodes,\n    edges,\n    graphInterface\n  );\n  const hopsAdjacencyMatrix = new FloydWarshall(adjacencyMatrix).shortestPaths;\n\n  // make info objects for each hop\n  const hops = { 1: edges };\n  const addHop = (rowIndex, colIndex, hopDistance) => {\n    if (hopDistance > 1) {\n      if (!hops[hopDistance]) {\n        hops[hopDistance] = [];\n      }\n      let hop = makeHop(\n        nodes[rowIndex],\n        nodes[colIndex],\n        hopDistance,\n        graphInterface.getNodeId\n      );\n      hops[hopDistance].push(hop);\n    }\n  };\n\n  if (directed) {\n    iterateDirected(hopsAdjacencyMatrix, addHop);\n  } else {\n    iterateUndirected(hopsAdjacencyMatrix, addHop);\n  }\n\n  return hops;\n}\n", "export const graphInterfaceDefault = {\n  getNodeId: (node) => node,\n  getSource: (edge) => edge.source,\n  getTarget: (edge) => edge.target,\n  makeHop: (source, target, hopDistance, getNodeId) => ({\n    source: getNodeId(source),\n    target: getNodeId(target),\n    hopDistance,\n  }),\n};\n\nexport default graphInterfaceDefault;\n\nexport const graphInterfaceD3 = {\n  ...graphInterfaceDefault,\n};\n\nexport const graphInterfaceVisJS = {\n  ...graphInterfaceDefault,\n  getSource: (edge) => edge.from,\n  getTarget: (edge) => edge.to,\n  makeHop: (source, target, hopDistance, getNodeId) => ({\n    from: getNodeId(source),\n    to: getNodeId(target),\n    hopDistance,\n  }),\n};\n\nexport const graphInterfaceCytoscapeJS = {\n  getNodeId: (node) => node.data.id,\n  getSource: (edge) => edge.data.source,\n  getTarget: (edge) => edge.data.target,\n  makeHop: (source, target, hopDistance, getNodeId) => ({\n    data: {\n      source: getNodeId(source),\n      target: getNodeId(target),\n      hopDistance,\n    },\n  }),\n};\n"],
  "mappings": "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",
  "names": []
}
